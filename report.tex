\documentclass[english,10pt,twocolumn]{article}

\usepackage{times}
\usepackage{fullpage}
\usepackage{babel}
\usepackage{graphicx}


\begin{document}

\title{Unikernel Web Infrastucture}
\author{Nate Brennand, Gudbergur Erlendsson, Mishail Tupas}
\date{}
\maketitle
\thispagestyle{empty}

\begin{abstract}
  Traditional cloud infrastructure models typically consists of a cluster of full stack virtual machines running a standard OS kernel (usually Linux variant) on top of hardware that's managed with a hypervisor. This provides a simple and consistent platform to develop against but there is a lot of resource overhead around virtualizing all of these machines.
  Key-value datastores are a common component of web infrastructure.
  We've designed a MirageOS\cite{mirage} unikernel implementation of the popular Redis\cite{redis} key-value store that allows fast creation and deployment of the datastore as well as ease scaling up the allocated resources.
  We describe the advantages and disadvantages that come with such a system.
  We highlight the performance characteristics of this new approach in comparison to Redis.
\end{abstract}

\section{Introduction}
In-memory key-value datastores are used in a wide variety of applications for ease of use and the high throughput.
While these applications are known for their great performance, research has shown that networked applications striving for low latency, such as Redis, are actually subjected to a high amount of overhead from utilizing Linux's networking stack.\cite{arrakis}
This issue is amplified by the lack of stability when running on Linux itself which is prone to performance dips when the resource scheduler is not coordinated.

We believe that the approach of moving the key-value datastore to a unikernel implementation will yield greater and more reliable performance.
A unikernel is a specialzed application capable of running directly on top of bare-metal or a hypervisor without a host operating system.
The unikernel approach lacks many of the performance issues plaguing Redis that cannot be resolved at the application level.
We build on top of the MirageOS\cite{mirage}, an OCaml based library operating system that provides type-safe networking libraries.

We measure the performance characteristics of Redis in multiple situations, networked and on-host, to yield a direct comparison to our implementation, Kayvee.
Kayvee speaks the Redis Serialization Protocol\cite{redis-protocol}, RESP, which makes Kayvee a drop in replacement for Redis in any deployment utilizing the Xen Hypervisor.


\section{Background}
% unikernel backgorund
The unikernel concept was first outlined X.

Today there are server operating systems developed for cloud computing that based on the concept of unikernels. MirageOS is a library operating system written in Ocaml that is commonly used for constructing unikernels.

% key-value datastore background
(What are key-value stores for?) 

Redis, short for Remote Dictionary server, is a key-value store software that is commonly used in distributed systems on virtualized operating systems. It features (). However, this software is generally run atop a full operating system installation, which incurs a certain degree of overhead as discussed previously.  While the OSv operating system can support Redis, it does not function optimally.

\section{Design and Implementation}

The MirageOS unikernel library operating system is leveraged to provide a correct and compact implementation. MirageOS leverages the Ocaml language to provide type safety at a low level, this creates many guarantees in terms of correctness.
GET Operation
SET Operation
Evaluation

To test the unikernel implementation, we utilized two of the benchmarking tools provided by the  ocam development kit. To get execution counts, the profiler “ocamlprof”, a part of the ocaml toolchain was used, inserting relevant information as comments to the code. To get detailed execution time information, the unikernel was compiled to include profiling information for the gprof tool.

Redis’ benchmarking tool was used to get data for comparison, running on both as a host system and a virtual machine. The Redis benchmarking tool was limited to four tests: inline ping, bulk ping, get method, and set method. For all tests, the benchmark made one million requests across fifty simulated parallel clients using a payload of three bytes.

The main point of comparison is the relative runtime of the unikernel implementation versus the two Redis setups. For each of the methods that were implemented
Collected Results

So far, the only benchmarks that have been completed were the Redis benchmarks for both the host-to-host setup and the native host setup. Preliminary benchmarks for the unikernel have been run.

SET Operation


\section{Related Work}

HaLVM\cite{halvm} and LING\cite{ling} are both alternatives to Mirage OS, using Haskell and Erlang respectively as the basis of their unikernel efforts. With all of these, you are limited to one functional language and the image is then built to run on top of the Xen hypervisor. Mirage OS and LING focuses on performance and predictability while HalVM focuses more on elegant compositional semantics using Haskell. Low level libraries are being implemented for the platforms in their native code, so while the work is ongoing the level of support varies. Mirage OS for example has a more mature SSL library and better support for encrypted connections then the other platforms.

OSv\cite{osv} is another variant to the special-purpose operating system using the library OS paradigm. In OSv everything runs in the kernel space and it's built to run as guest on top of a virtual machine. However, it contains necessary functionality to run Java and POSIX applications which allows OSv to run some existing codebases and get some of the performance benefit Mirage enjoys. Mirage however focuses on a toolkit to assemble new unikernel application without specific domain knowledge in kernel programming for example.

Arrakis\cite{arrakis}, SPIN\cite{spin} and Exokernel\cite{exokernel} all reduce shared kernel components and allow each application to have customized operating system management, achieving some of the increased performance benefit of Mirage OS without tying you to one language runtime.  Arrakis in particular benefits from increased support for virtualization in new hardware, which allows it to effectively run all applications in kernel space and achieve seperation using hardware instructions, similar to how Mirage OS achieves seperation through Xen.


\bibliographystyle{abbrv}
\bibliography{bibliography}


\end{document}



